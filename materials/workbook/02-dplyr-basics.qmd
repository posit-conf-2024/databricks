---
title: "dplyr basics"
execute: 
  eval: true
  freeze: true
---


```{r, setup}
#| include: false
library(dplyr)
library(dbplyr)
library(DBI)
```

## Create a table variable

*Basics to how to point a variable in R to a table or view inside the database*

1. Load the `dplyr`, `DBI` and `dbplyr` libraries
```{r, dplyr}
library(dplyr)
library(dbplyr)
library(DBI)
```

2. *(Optional)* Open a connection to the database if it's currently closed
```{r}
con <- dbConnect(
  odbc::databricks(),
  HTTPPath = "/sql/1.0/warehouses/300bd24ba12adf8e"
)
```

3. Using `dbGetQuery()` create a query that pulls the top 10 rows form `cars`

```{r}
dbGetQuery(con, "select * from cars")
```

4. Use the `tbl()` to perform the same. Notice how it automatically only shows 
the top 10
```{r}
tbl(con, "cars")
```

4. Load the reference, not the table data, into a variable
```{r}
tbl_cars <- tbl(con, "cars")
```


5. Call the variable to see preview the data in the table
```{r}
tbl_cars
```

6. Add `count()` to easily get the number of rows
```{r}
tbl_cars %>% 
  count()
```

7. Add `am` as an argument to `count()` to see the count by that field
```{r}
tbl_cars %>% 
  count(am)
```

8. Add `show_query()` to see the how `dplyr` translates your code to 
SQL 

```{r}
tbl_cars %>% 
  count(am) %>% 
  show_query()
```
## Easily aggretate data
*An example of how we can use the same code against a local R data frame and a remote table*

1. Using `dplyr`, get the average `mpg` for each `am`, and sort it by the
average for `mtcars`

```{r}
mtcars %>% 
  group_by(cyl) %>% 
  summarise(avg_mpg = mean(mpg, na.rm = TRUE)) %>% 
  arrange(desc(avg_mpg))
```

2. Use `tbl_cars` to perform the exact same operation 

```{r}
tbl_cars %>% 
  group_by(cyl) %>% 
  summarise(avg_mpg = mean(mpg, na.rm = TRUE)) %>% 
  arrange(desc(avg_mpg))
```

3. Add `show_query()` to see what R sent to Databricks

```{r}
tbl_cars %>% 
  group_by(cyl) %>% 
  summarise(avg_mpg = mean(mpg, na.rm = TRUE)) %>% 
  arrange(desc(avg_mpg)) %>%
  show_query()
```

## Un-translated R commands
*Review of how `dbplyr` handles R commands that have not been translated into a like-SQL command*

1. Preview how `Sys.time()` is translated
```{r}
tbl_cars %>%
  mutate(today = Sys.time()) %>%
  select(today) %>% 
  show_query()
```

2. Use Databricks's native commands, in this case `current_date()` 
(https://docs.databricks.com/en/sql/language-manual/functions/current_date.html)
```{r}
tbl_cars %>%
  mutate(today = current_date()) %>%
  select(today) %>% 
  show_query()
```

3. Run the `dplyr` code to confirm it works
```{r}
tbl_cars %>%
  mutate(today = current_date()) %>%
  select(today) %>%
  head()
```

## Using bang-bang
*Intro on passing unevaluated code to a dplyr verb*

1. Preview how `Sys.time()` is translated
```{r}
tbl_cars %>%
  mutate(today = Sys.time()) %>%
  show_query()
```

2. Preview how `Sys.time()` is translated when prefixing `!!`
```{r}
tbl_cars %>%
  mutate(today = !! Sys.time()) %>%
  show_query()
```

3. Preview how `Sys.time()` is translated when prefixing `!!`
```{r}
tbl_cars %>%
  mutate(today = !!Sys.time()) %>%
  select(today) %>%
  head()
```

## knitr SQL engine

1. Copy the result of the latest `show_query()` exercise
```{r}
tbl_cars %>%
  mutate(today = !!Sys.time()) %>%
  select(today) %>% 
  show_query()
```

2. Paste the result in this SQL chunk
```{sql, connection = con}
SELECT '2024-05-26T20:35:56Z' AS `today`
FROM `cars`
```


```{r, include = FALSE}
dbDisconnect(con)
```
